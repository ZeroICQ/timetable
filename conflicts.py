import conditions

conflict_types = ((1, 'Совпадение аудиторий'),
                  (2, 'Совпадение преподавателей'))


class BaseConflict:
    def fill_conflict_db(self, conflicts, type, sched_conflict_model, conflit_conflict_model):
        # pk = sched_conflict_model.pk.qualified_col_name

        for conflict_pk in conflicts:
            new_entry = {
                sched_conflict_model.conflict.qualified_col_name: type,
                sched_conflict_model.sched_item.qualified_col_name: conflict_pk
            }
            sched_conflict_model.insert(new_entry)

            for related_conflict in conflicts:
                if conflict_pk == related_conflict:
                    continue

                new_conflict_conflit_entry = {
                    conflit_conflict_model.id1.qualified_col_name: conflict_pk,
                    conflit_conflict_model.id2.qualified_col_name: related_conflict
                }
                conflit_conflict_model.insert(new_conflict_conflit_entry)

    def full_recalculate(self, data, sched_model, sched_conflicts_model, conflict_conflict_model, type):
        pk = sched_model.pk.qualified_col_name
        used = set()

        for entry in data:
            conflicting_entries = []

            if entry[pk] in used:
                continue

            conflicting_entries.append(entry[pk])
            used.add(entry[pk])

            for suspect in data:
                if suspect[pk] in used:
                    continue

                if self.compare(entry, suspect, sched_model):
                    used.add(suspect[pk])
                    conflicting_entries.append(suspect[pk])

            if len(conflicting_entries) > 1:
                self.fill_conflict_db(conflicting_entries, type, sched_conflicts_model, conflict_conflict_model)

    '''return true if conflict exists'''
    def compare(self, entry, suspect, sched_model):
        pass


class AudienceOverlap(BaseConflict):
    def __init__(self):
        super().__init__()

    def full_recalculate(self, data, sched_model, sched_conflicts_model, conflict_conflict_model, type=1):
        super().full_recalculate(data, sched_model, sched_conflicts_model, conflict_conflict_model, type)

    def compare(self, entry, suspect, sched_model):
        return (entry[sched_model.weekday.qualified_col_name] == suspect[sched_model.weekday.qualified_col_name] and
                entry[sched_model.lesson.qualified_col_name] == suspect[sched_model.lesson.qualified_col_name] and
                entry[sched_model.audience.qualified_col_name] == suspect[sched_model.audience.qualified_col_name])


all_conflicts = (
    AudienceOverlap(),
)


def recalculate_all(cur, sched_conflicts_model, conflicts_model, sched_model, conflict_conflict_model):
    # RECREATE ALL TABLES
    cur.execute('''RECREATE TABLE {table_name}
                (
                    ID Integer GENERATED BY DEFAULT AS IDENTITY,
                    {col1_name} Integer NOT NULL,
                    {col2_name} Integer NOT NULL,
                    PRIMARY KEY (ID),
                    CONSTRAINT UNIQ_CONFLICT_CONFLICT UNIQUE ({col1_name}, {col2_name})
                )'''.format(table_name=conflict_conflict_model.table_name,
                            col1_name=conflict_conflict_model.id1.col_name,
                            col2_name=conflict_conflict_model.id2.col_name))

    cur.execute('''RECREATE TABLE {table_name}
                (
                    ID Integer GENERATED BY DEFAULT AS IDENTITY,
                    CONFLICT_ID Integer NOT NULL,
                    SCHED_ID Integer NOT NULL,
                    PRIMARY KEY (ID)
                )'''.format(table_name=sched_conflicts_model.table_name))

    cur.execute('''RECREATE TABLE {table_name}
                (
                    ID Integer NOT NULL,
                    NAME Varchar(255) NOT NULL,
                    PRIMARY KEY (ID)
                );
                '''.format(table_name=conflicts_model.table_name))

    cur.execute('''ALTER TABLE {sched_conflicts_table_name} ADD
                    FOREIGN KEY ({conflict_id_col_name}) REFERENCES {conflicts_table_name} (ID)
                    ON DELETE CASCADE
                    ON UPDATE CASCADE;'''.format(sched_conflicts_table_name=sched_conflicts_model.table_name,
                                                 conflict_id_col_name=sched_conflicts_model.conflict.col_name,
                                                 conflicts_table_name=conflicts_model.table_name))

    cur.execute('''ALTER TABLE {sched_conflicts_table_name} ADD
                        FOREIGN KEY ({conflict_id_col_name}) REFERENCES {conflicts_table_name} (ID)
                        ON DELETE CASCADE
                        ON UPDATE CASCADE;'''.format(sched_conflicts_table_name=sched_conflicts_model.table_name,
                                                     conflict_id_col_name=sched_conflicts_model.sched_item.col_name,
                                                     conflicts_table_name=sched_model.table_name))

    cur.execute('''ALTER TABLE {conflict_conflict} ADD
                        FOREIGN KEY ({id1}) REFERENCES {sched} (ID)
                        ON DELETE CASCADE
                        ON UPDATE CASCADE;'''.format(conflict_conflict=conflict_conflict_model.table_name,
                                                     id1=conflict_conflict_model.id1.col_name,
                                                     sched=sched_model.table_name))

    cur.execute('''ALTER TABLE {conflict_conflict} ADD
                            FOREIGN KEY ({id2}) REFERENCES {sched} (ID)
                            ON DELETE CASCADE
                            ON UPDATE CASCADE;'''.format(conflict_conflict=conflict_conflict_model.table_name,
                                                         id2=conflict_conflict_model.id2.col_name,
                                                         sched=sched_model.table_name))

    cur.transaction.commit()
    cur.executemany('INSERT INTO {tablename} values (?, ?)'.format(tablename=conflicts_model.table_name), conflict_types)

    data = sched_model.fetch_all(return_fields=sched_model.fields)

    for conflict in all_conflicts:
        conflict.full_recalculate(data, sched_model, sched_conflicts_model, conflict_conflict_model)