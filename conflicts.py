import conditions

# conflict_types = ((1, 'Совпадение аудиторий'),
#                   (2, 'Совпадение преподавателей'))

class BaseConflict:
    title = 'Название конфликта'

    def fill_conflict_db(self, conflicts, type, sched_conflict_model, group):
        # pk = sched_conflict_model.pk.qualified_col_name

        for conflict_pk in conflicts:
            new_entry = {
                sched_conflict_model.conflict.qualified_col_name: type,
                sched_conflict_model.sched_item.qualified_col_name: conflict_pk,
                sched_conflict_model.con_group.qualified_col_name: group
            }
            sched_conflict_model.insert(new_entry)

    def full_recalculate(self, data, sched_model, sched_conflicts_model, type):
        pk = sched_model.pk.qualified_col_name
        used = set()

        cur_group = 1
        for entry in data:
            conflicting_entries = []

            if entry[pk] in used:
                continue

            conflicting_entries.append(entry[pk])
            used.add(entry[pk])

            for suspect in data:
                if suspect[pk] in used:
                    continue

                if self.compare(entry, suspect, sched_model):
                    used.add(suspect[pk])
                    conflicting_entries.append(suspect[pk])

            if len(conflicting_entries) > 1:
                self.fill_conflict_db(conflicting_entries, type, sched_conflicts_model, cur_group)
                cur_group += 1

    '''return true if conflict exists'''
    def compare(self, entry, suspect, sched_model):
        pass


class AudienceOverlap(BaseConflict):
    title = 'Совпадение аудиторий'
    alias = 'audience_overlap'

    def __init__(self):
        super().__init__()

    def full_recalculate(self, data, sched_model, sched_conflicts_model, type=1):
        super().full_recalculate(data, sched_model, sched_conflicts_model, type)

    def compare(self, entry, suspect, sched_model):
        return (entry[sched_model.weekday.qualified_col_name] == suspect[sched_model.weekday.qualified_col_name] and
                entry[sched_model.lesson.qualified_col_name] == suspect[sched_model.lesson.qualified_col_name] and
                entry[sched_model.audience.qualified_col_name] == suspect[sched_model.audience.qualified_col_name])


all_conflicts = (
    AudienceOverlap(),
)


def recalculate_all(cur, sched_conflicts_model, conflicts_model, sched_model):
    # RECREATE ALL TABLES
    cur.execute('''RECREATE TABLE {table_name}
                (
                    ID Integer GENERATED BY DEFAULT AS IDENTITY,
                    CONFLICT_ID Integer NOT NULL,
                    SCHED_ID Integer NOT NULL,
                    CON_GROUP Integer NOT NULL,
                    PRIMARY KEY (ID)
                )'''.format(table_name=sched_conflicts_model.table_name))

    cur.execute('''RECREATE TABLE {table_name}
                (
                    ID Integer NOT NULL,
                    NAME Varchar(255) NOT NULL,
                    PRIMARY KEY (ID)
                );
                '''.format(table_name=conflicts_model.table_name))

    cur.execute('''ALTER TABLE {sched_conflicts_table_name} ADD
                    FOREIGN KEY ({conflict_id_col_name}) REFERENCES {conflicts_table_name} (ID)
                    ON DELETE CASCADE
                    ON UPDATE CASCADE;'''.format(sched_conflicts_table_name=sched_conflicts_model.table_name,
                                                 conflict_id_col_name=sched_conflicts_model.conflict.col_name,
                                                 conflicts_table_name=conflicts_model.table_name))

    cur.execute('''ALTER TABLE {sched_conflicts_table_name} ADD
                        FOREIGN KEY ({conflict_id_col_name}) REFERENCES {conflicts_table_name} (ID)
                        ON DELETE CASCADE
                        ON UPDATE CASCADE;'''.format(sched_conflicts_table_name=sched_conflicts_model.table_name,
                                                     conflict_id_col_name=sched_conflicts_model.sched_item.col_name,
                                                     conflicts_table_name=sched_model.table_name))

    cur.transaction.commit()
    cur.executemany('INSERT INTO {tablename} values (?, ?)'.format(tablename=conflicts_model.table_name),
                    [(idx+1, c.title) for idx, c in enumerate(all_conflicts)])

    data = sched_model.fetch_all(return_fields=sched_model.fields)

    for conflict in all_conflicts:
        conflict.full_recalculate(data, sched_model, sched_conflicts_model)